esphome:
  name: upstairs-hvac
  friendly_name: Upstairs-HVAC
  name_add_mac_suffix: false
  on_boot:
    priority: -100  # Run after modbus controller is initialized
    then:
      - delay: 5s  # Wait for initial modbus reads
      - lambda: |-
          // Set default values if current state is unknown/invalid at boot
          if (id(${devicename}_operational_mode).state.empty() || id(${devicename}_operational_mode).state == "Unknown") {
            ESP_LOGW("boot", "Operational Mode state unknown, defaulting to Off");
            auto call = id(${devicename}_operational_mode).make_call();
            call.set_option("Off");
            call.perform();
          }
          if (id(${devicename}_fan_mode).state.empty() || id(${devicename}_fan_mode).state == "Unknown") {
            ESP_LOGW("boot", "Fan Mode state unknown, defaulting to Auto");
            auto call = id(${devicename}_fan_mode).make_call();
            call.set_option("Auto");
            call.perform();
          }

substitutions:
  devicename: heatpump
  description: Heatpump Controller - Air Handler Configuration

globals:
  - id: unmasked_value_register_0
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_5
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_4
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_210
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_211
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: compressor_start_count
    type: int
    restore_value: no
    initial_value: '0'
  - id: use_fahrenheit
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: freeze_protection_temp
    type: float
    restore_value: no
    initial_value: '50.0'  # Default: 50°F
  - id: overheat_protection_temp
    type: float
    restore_value: no
    initial_value: '95.0'  # Default: 95°F
  - id: protection_mode_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: using_fallback_temp_sensor
    type: bool
    restore_value: no
    initial_value: 'false'

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO
  baud_rate: 0

# Enable Home Assistant API
api:

web_server:
  port: 80
  version: 3

ota:
  platform: esphome
  password: !secret OTA_pin
  port: 3232

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: !secret domain_url
  fast_connect: True

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Upstairs-Hvac Fallback Hotspot"
    password: !secret wifi_password
captive_portal:

uart:
  id: mod_bus
  tx_pin: 17
  rx_pin: 16
  baud_rate: 4800 #9600
  stop_bits: 1

modbus:
 # flow_control_pin: 5 NOT Used With https://www.amazon.com/dp/B0BKG7SC54?ref_=ppx_hzsearch_conn_dt_b_fed_asin_title_5
  id: heatpump_modbus

modbus_controller:
  - id: "${devicename}"
    address: 0x1
    modbus_id: heatpump_modbus
    setup_priority: -10
    update_interval: 10s

select:
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Operational Mode"
    id: "${devicename}_operational_mode"
    icon: "mdi:fan"
    address: 0x1
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Off": 0
      "Auto": 1
      "Cool": 2
      "Heat": 3
      "Dry": 4
      "Fan Only": 5

  # EXPERIMENTAL FAN MODE CONTROL
  # WARNING: This is based on old XYE serial protocol mappings and may not work correctly
  # The correct modbus register and value mappings are unknown and need verification
  # Old XYE protocol used: 0x80=auto, 0x01=high, 0x02=medium, 0x03=low
  # This implementation attempts register 0x4 which is a common fan control register
  # TODO: Verify correct register address and value mappings through modbus monitoring
  # TODO: Test each mode to confirm proper operation
  # If this doesn't work, try:
  #   - Different register addresses (0x2, bits in 0x5, etc.)
  #   - Different value mappings
  #   - Monitor physical controller changes to identify correct register
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fan Mode (Experimental)"
    id: "${devicename}_fan_mode"
    icon: "mdi:fan-speed-1"
    address: 0x4
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Auto": 0
      "Low": 3
      "Medium": 2
      "High": 1

sensor:
  - platform: dht
    pin: 13
    model: DHT11
    temperature:
      name: "Adapter_Temp"
      id: "${devicename}_adapter_temp"
    humidity:
      name: "Adapter_Humidity"
      id: "${devicename}_adapter_humidity"
    update_interval: 10s
    
  - platform: template
    name: "Compressor Starts Per Hour"
    id: compressor_starts_per_hour
    unit_of_measurement: "starts/h"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return id(compressor_start_count);

  - platform: uptime
    name: Uptime
    id: "${devicename}_uptime"
    icon: mdi:timelapse
    
  - platform: wifi_signal
    name: "WiFi Signal"
    id: "${devicename}_wifi_signal"
    icon: mdi:wifi
    update_interval: 30s
    
  - platform: template
    name: "Freeze Protection Threshold"
    id: "${devicename}_freeze_protection_threshold"
    icon: mdi:snowflake-alert
    accuracy_decimals: 1
    unit_of_measurement: "°F"
    entity_category: diagnostic
    lambda: |-
      return id(freeze_protection_temp);
      
  - platform: template
    name: "Overheat Protection Threshold"
    id: "${devicename}_overheat_protection_threshold"
    icon: mdi:fire-alert
    accuracy_decimals: 1
    unit_of_measurement: "°F"
    entity_category: diagnostic
    lambda: |-
      return id(overheat_protection_temp);
      
  - platform: template
    name: "Coefficient of Performance"
    id: "${devicename}_coefficient_of_performance"
    icon: mdi:copyleft
    accuracy_decimals: 2
    unit_of_measurement: "COP"
    lambda: |-
      // Verify that electricity_consumption is <> 0 to avoid division by 0 error
      if (id(${devicename}_electricity_consumption).state != 0) {
        return id(${devicename}_power_output).state / id(${devicename}_electricity_consumption).state;
      } else return {};
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 0 switches"
    id: "${devicename}_register_0_switches"
    internal: true
    register_type: holding
    address: 0x0
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_0
      id(unmasked_value_register_0) = x;
      return x;
      
  # EXPERIMENTAL: Monitor register 0x4 for fan mode debugging
  # This sensor helps verify if register 0x4 is the correct fan control register
  # Watch this value when changing fan mode via physical controller
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 4 Fan Mode (Debug)"
    id: "${devicename}_register_4_fan_mode"
    internal: true
    register_type: holding
    address: 0x4
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_4
      id(unmasked_value_register_4) = x;
      ESP_LOGI("fan_mode", "Register 0x4 value: 0x%04X (%d)", x, x);
      return x;
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 5 switches"
    id: "${devicename}_register_5_switches"
    internal: true
    register_type: holding
    address: 0x5
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_5
      id(unmasked_value_register_5) = x;
      return x;

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Operating Frequency"
    id: "${devicename}_compressor_operating_frequency"
    icon: mdi:sine-wave
    register_type: holding
    address: 0x64
    value_type: U_WORD
    unit_of_measurement: Hz
    device_class: "frequency"
    state_class: "measurement"
    
  # EXPERIMENTAL: Unknown register 0x65
  # Located between Compressor Operating Frequency and Fan Speed
  # Could be compressor-related status or additional frequency data
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Debug Register 0x65"
    id: "${devicename}_debug_register_0x65"
    internal: true
    register_type: holding
    address: 0x65
    value_type: U_WORD
    icon: mdi:help-circle
    lambda: |-
      if (x != 0) {
        ESP_LOGI("debug", "Register 0x65 value: 0x%04X (%d)", x, x);
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fan Speed"
    id: "${devicename}_fan_speed"
    icon: mdi:fan
    register_type: holding
    address: 0x66
    unit_of_measurement: "r/min"
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "PMV Openness"
    id: "${devicename}_pmv_openness"
    icon: mdi:valve
    register_type: holding
    address: 0x67
    value_type: U_WORD
    unit_of_measurement: "%"
    filters:
      - calibrate_linear:
          - 0 -> 0.0
          - 480 -> 100.0
          
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Coil Inlet Temperature"
    id: "${devicename}_coil_inlet_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0x68
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_coil_inlet_temperature).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_coil_inlet_temperature).set_unit_of_measurement("°C");
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Coil Outlet Temperature"
    id: "${devicename}_coil_outlet_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0x69
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_coil_outlet_temperature).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_coil_outlet_temperature).set_unit_of_measurement("°C");
      }
      return x;
          
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Condenser Temperature T3"
    id: "${devicename}_condenser_temperature_t3"
    icon: mdi:thermometer
    register_type: holding
    address: 0x6a
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_condenser_temperature_t3).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_condenser_temperature_t3).set_unit_of_measurement("°C");
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Ambient Temperature"
    id: "${devicename}_outdoor_ambient_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0x6B
    device_class: "temperature"
    state_class: "measurement"
    value_type: S_WORD
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_outdoor_ambient_temperature).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_outdoor_ambient_temperature).set_unit_of_measurement("°C");
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Discharge Temperature"
    id: "${devicename}_discharge_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0x6c
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_discharge_temperature).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_discharge_temperature).set_unit_of_measurement("°C");
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Return Air Temperature"
    id: "${devicename}_return_air_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0x6d
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_return_air_temperature).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_return_air_temperature).set_unit_of_measurement("°C");
      }
      return x;
    
  # EXPERIMENTAL: Unknown register 0x6e - Possible Suction Temperature (Th)
  # Error code 10 references "Suction temp. sensor (Th) fault"
  # This register falls in the temperature sensor range
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Debug Temperature 0x6e (Th?)"
    id: "${devicename}_debug_temp_0x6e"
    internal: true
    register_type: holding
    address: 0x6e
    value_type: S_WORD
    icon: mdi:help-circle
    lambda: |-
      if (x != 0 && x > -100 && x < 200) {  // Reasonable temperature range
        ESP_LOGI("debug", "Register 0x6e (Th?) value: %d°C (%.1f°F)", x, x * 1.8 + 32.0);
      }
      return x;
      
  # EXPERIMENTAL: Unknown register 0x6f
  # Could be another temperature sensor
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Debug Temperature 0x6f"
    id: "${devicename}_debug_temp_0x6f"
    internal: true
    register_type: holding
    address: 0x6f
    value_type: S_WORD
    icon: mdi:help-circle
    lambda: |-
      if (x != 0 && x > -100 && x < 200) {  // Reasonable temperature range
        ESP_LOGI("debug", "Register 0x6f value: %d°C (%.1f°F)", x, x * 1.8 + 32.0);
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Refrigerant Liquid Side Temperature T2"
    id: "${devicename}_refrigerant_liquid_side_temperature_t2"
    icon: mdi:thermometer
    register_type: holding
    address: 0x70
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_refrigerant_liquid_side_temperature_t2).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_refrigerant_liquid_side_temperature_t2).set_unit_of_measurement("°C");
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Refrigerant Gas Side Temperature T2B"
    id: "${devicename}_refrigerant_gas_side_temperature_t2b"
    icon: mdi:thermometer
    register_type: holding
    address: 0x71
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_refrigerant_gas_side_temperature_t2b).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_refrigerant_gas_side_temperature_t2b).set_unit_of_measurement("°C");
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Room Temperature Ta"
    id: "${devicename}_room_temperature_ta"
    icon: mdi:thermometer
    register_type: holding
    address: 0x72
    value_type: S_WORD
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (id(use_fahrenheit)) {
            return x * 1.8 + 32.0;
          }
          return x;
    unit_of_measurement: ""
    lambda: |-
      if (id(use_fahrenheit)) {
        id(${devicename}_room_temperature_ta).set_unit_of_measurement("°F");
      } else {
        id(${devicename}_room_temperature_ta).set_unit_of_measurement("°C");
      }
      return x;
    
  # EXPERIMENTAL: Unknown register 0x73
  # Located between Room Temperature and Pressures
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Debug Register 0x73"
    id: "${devicename}_debug_register_0x73"
    internal: true
    register_type: holding
    address: 0x73
    value_type: U_WORD
    icon: mdi:help-circle
    lambda: |-
      if (x != 0) {
        ESP_LOGI("debug", "Register 0x73 value: 0x%04X (%d)", x, x);
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit High Pressure"
    id: "${devicename}_outdoor_unit_high_pressure"
    icon: mdi:car-brake-worn-linings
    register_type: holding
    address: 0x74
    value_type: U_WORD
    unit_of_measurement: kPa
    device_class: "pressure"
    state_class: "measurement"
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Low Pressure"
    id: "${devicename}_outdoor_unit_low_pressure"
    icon: mdi:car-brake-low-pressure
    register_type: holding
    address: 0x75
    value_type: U_WORD
    unit_of_measurement: kPa
    device_class: "pressure"
    state_class: "measurement"
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Current"
    id: "${devicename}_outdoor_unit_current"
    icon: mdi:alpha-a
    register_type: holding
    address: 0x76
    value_type: U_WORD
    unit_of_measurement: A
    device_class: "current"
    state_class: "measurement"
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Voltage"
    id: "${devicename}_outdoor_unit_voltage"
    icon: mdi:alpha-v
    register_type: holding
    address: 0x77
    value_type: U_WORD
    unit_of_measurement: V
    device_class: "voltage"
    state_class: "measurement"
    
  # EXPERIMENTAL: Unknown registers 0x78 and 0x79
  # Located between Voltage and Compressor Operation Time
  # Could be additional operational data or statistics
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Debug Register 0x78"
    id: "${devicename}_debug_register_0x78"
    internal: true
    register_type: holding
    address: 0x78
    value_type: U_WORD
    icon: mdi:help-circle
    lambda: |-
      if (x != 0) {
        ESP_LOGI("debug", "Register 0x78 value: 0x%04X (%d)", x, x);
      }
      return x;
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Debug Register 0x79"
    id: "${devicename}_debug_register_0x79"
    internal: true
    register_type: holding
    address: 0x79
    value_type: U_WORD
    icon: mdi:help-circle
    lambda: |-
      if (x != 0) {
        ESP_LOGI("debug", "Register 0x79 value: 0x%04X (%d)", x, x);
      }
      return x;
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Operation Time"
    id: "${devicename}_compressor_operation_time"
    icon: mdi:av-timer
    register_type: holding
    address: 0x7a
    value_type: U_WORD
    unit_of_measurement: hr
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Unit Capacity"
    id: "${devicename}_unit_capacity"
    icon: mdi:lightning-bolt-circle
    register_type: holding
    address: 0x7b
    value_type: U_WORD
    unit_of_measurement: "kWh"
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Current Fault"
    id: "${devicename}_current_fault"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7c
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 1"
    id: "${devicename}_fault_1"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7d
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 2"
    id: "${devicename}_fault_2"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7e
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 3"
    id: "${devicename}_fault_3"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7f
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Software Version"
    id: "${devicename}_software_version"
    icon: mdi:information
    register_type: holding
    address: 0x82
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Wired Controller Version Number"
    id: "${devicename}_wired_controller_version_number"
    icon: mdi:information
    register_type: holding
    address: 0x83
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Target Frequency"
    id: "${devicename}_compressor_target_frequency"
    icon: mdi:sine-wave
    register_type: holding
    address: 0x84
    value_type: U_WORD
    unit_of_measurement: Hz
    device_class: "frequency"
    state_class: "measurement"
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DC Bus Current"
    id: "${devicename}_dc_bus_current"
    icon: mdi:alpha-a
    register_type: holding
    address: 0x85
    value_type: U_WORD
    unit_of_measurement: A
    device_class: "current"
    state_class: "measurement"
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DC Bus Voltage"
    id: "${devicename}_dc_bus_voltage"
    icon: mdi:alpha-v
    register_type: holding
    address: 0x86
    value_type: U_WORD
    unit_of_measurement: V
    device_class: "voltage"
    state_class: "measurement"
    filters:
      - multiply: 10
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "TF module temperature"
    id: "${devicename}_tf_module_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0x87
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    value_type: S_WORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Electricity Consumption"
    id: "${devicename}_electricity_consumption"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x8f
    value_type: U_DWORD
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Output"
    id: "${devicename}_power_output"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x91
    value_type: U_DWORD

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Parameter Settings 1"
    id: "${devicename}_parameter_settings_1"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 210
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_210
      id(unmasked_value_register_210) = x;
      return x;
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Parameter Settings 2"
    id: "${devicename}_parameter_settings_2"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 211
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_211
      id(unmasked_value_register_211) = x;
      return x;

binary_sensor:
  - platform: template
    name: "Compressor Running"
    id: compressor_running
    device_class: running
    lambda: |-
      return id(${devicename}_compressor_operating_frequency).state > 0;
      
  - platform: template
    name: "Temperature Protection Active"
    id: "${devicename}_temperature_protection_active"
    device_class: safety
    icon: mdi:shield-alert
    lambda: |-
      return id(protection_mode_active);
      
  - platform: template
    name: "DHT11 Sensor OK"
    id: "${devicename}_dht11_sensor_ok"
    device_class: problem
    icon: mdi:thermometer-check
    entity_category: diagnostic
    lambda: |-
      // device_class: problem - true = problem exists, false = no problem
      float dht_temp = id(${devicename}_adapter_temp).state;
      return isnan(dht_temp);  // Return true (problem) when sensor reading is NaN

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Defrosting"
    id: "${devicename}_status_bit_1_defrosting"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x2
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Anti Freezing"
    id: "${devicename}_status_bit_1_anti_freezing"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x4
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Oil Return"
    id: "${devicename}_status_bit_1_oil_return"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x8
    
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Remote On/Off"
    id: "${devicename}_status_bit_1_remote_on_off"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x10

switch:
  - platform: factory_reset
    name: Restart with Factory Default Settings
    id: "${devicename}_restart_with_factory_default_settings"
    icon: mdi:restart-alert
    
  - platform: template
    name: "Temperature Unit (Fahrenheit)"
    id: "${devicename}_temperature_unit_fahrenheit"
    icon: mdi:thermometer
    entity_category: config
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    lambda: "return id(use_fahrenheit);"
    on_turn_on:
      - lambda: "id(use_fahrenheit) = true;"
    on_turn_off:
      - lambda: "id(use_fahrenheit) = false;"
    
  - platform: template
    name: "Function Setting Silent Mode"
    id: "${devicename}_function_setting_silent_mode"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x40) == 0x40;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          
  - platform: template
    name: "Function Setting ECO Mode"
    id: "${devicename}_function_setting_eco_mode"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x400) == 0x400;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }

number:
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set Temperature"
    id: "${devicename}_air_temperature_ts"
    icon: mdi:thermometer
    register_type: holding
    address: 0x3
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    min_value: 17
    max_value: 30
    step: 0.5
    mode: slider
    lambda: |-
      return x * 0.5;
    write_lambda: |-
      return x * 2.0;

text_sensor:
  - platform: version
    name: "ESPHome Version"
    id: "${devicename}_esphome_version"
    icon: mdi:information
    hide_timestamp: true
    
  - platform: template
    name: "Temperature Protection Sensor Source"
    id: "${devicename}_temp_protection_source"
    icon: mdi:thermometer-alert
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      float dht_temp = id(${devicename}_adapter_temp).state;
      float return_temp = id(${devicename}_return_air_temperature).state;
      
      if (!isnan(dht_temp)) {
        return {"DHT11 Adapter Sensor"};
      } else if (!isnan(return_temp)) {
        return {"Return Air Sensor (Fallback)"};
      } else {
        return {"No Sensors Available - Protection Disabled!"};
      }
    
  - platform: template
    name: "Active State"
    id: "${devicename}_active_state"
    icon: mdi:power
    entity_category: "diagnostic"
    lambda: |-
      if (id(${devicename}_operational_mode).state != "Off") {
        if (id(${devicename}_compressor_operating_frequency).state > 0 || id(${devicename}_fan_speed).state > 0) {
          // The heat pump is on
          if (id(${devicename}_status_bit_1_defrosting).state) {
            return {"Defrosting"};
          } else if (id(${devicename}_status_bit_1_oil_return).state) {
            return {"Oil return"};
          } else {
            // Return the state from "Operational Mode", which can be Cooling or Heating
            return id(${devicename}_operational_mode).state;
          }
        } else {
          // The heat pump's operational mode is on (not OFF), but is not running
          // In this case the heat pump is Idle
          return {"Idle"};
        }
      } else {
        // The heat pump is off
        return {"Inactive"};
      }
      
  - platform: template
    name: "Current Fault Error Code"
    id: "${devicename}_current_fault_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int current_fault = id(${devicename}_current_fault).state;
      if (current_fault >= 0 && current_fault <= 143) {
        return std::to_string(current_fault);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9

  - platform: template
    name: "Current Fault Error Code Description"
    id: "${devicename}_current_fault_error_code_description"
    icon: "mdi:alert-circle"
    lambda: |-
      int current_fault = id(${devicename}_current_fault).state;
      if (current_fault >= 0 && current_fault <= 143) {
        return std::to_string(current_fault);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> Water flow fault(E8 displayed 3 times)
          - 2 -> Phase loss or neutral wire and live wire are connected reversely(only for three phase unit)
          - 3 -> Communication fault between controller and hydraulic module
          - 4 -> Final outlet water temp. sensor(T1) fault
          - 5 -> Water tank temp. sensor(T5) fault
          - 6 -> The condenser outlet refrigerant temperature sensor(T3) fault
          - 7 -> The ambient temperature sensor(T4) fault
          - 8 -> Buffer tank up temp. sensor(Tbt1) fault
          - 9 -> Water flow failure
          - 10 -> Suction temp. sensor (Th) fault
          - 11 -> Discharge temp. sensor (Tp) fault
          - 12 -> Solar temp. sensor(Tsolar) fault
          - 13 -> Buffer tank low temp. sensor(Tbt2) fault
          - 14 -> Inlet water temp. sensor(Tw_in) malfunction
          - 15 -> Hydraulic module EEprom failure
          - 20 -> Low pressure switch protection
          - 21 -> High pressure switch protection
          - 23 -> Compressor overcurrent protection
          - 24 -> High discharge temperature protection
          - 25 -> |Tw_out - Tw_in| value too big protection
          - 26 -> Inverter module protection
          - 31 -> Anti-freeze mode
          - 33 -> High temperature protection of refrigerant outlet temp. of condenser
          - 38 -> Tw_out - Tw_in unusual protection
          - 39 -> Communication fault between main board PCB B and main control board of hydraulic module
          - 40 -> Communication fault between inverter module PCB A and main control board PCB B
          - 41 -> Refrigerant liquid temp. sensor(T2) fault
          - 42 -> Refrigerant gas temp. sensor(T2B) fault
          - 43 -> Three times P6(L0/L1) protection
          - 44 -> Room temp. sensor (Ta) fault
          - 45 -> DC fan motor fault
          - 46 -> Voltage protection
          - 47 -> Pressure sensor fault
          - 48 -> Outlet water for zone 2 temp. sensor(Tw2) fault
          - 49 -> Outlet water temp. sensor(Tw_out) fault
          - 50 -> 3 times PP protection and Tw_out<7℃
          - 52 -> Communication fault between hydraulic module parallel
          - 53 -> Communication error between main board and thermostat transfer board
          - 54 -> Inverter module board EE PROM fault
          - 55 -> H6 display 10 times in 2 hours
          - 57 -> Low pressure protection (Pe<0.6) occurred 3 times in 1 hour
          - 65 -> Transducer module temperature too high protection
          - 112 -> PED PCB fault
          - 116 -> Low DC generatrix voltage protection
          - 134 -> Module protection
          - 135 -> DC generatrix low voltage protection
          - 136 -> DC generatrix high voltage protection
          - 138 -> MCE fault
          - 139 -> Zero speed protection
          - 141 -> Phase sequence fault
          - 142 -> Speed difference > 15Hz protection between the front and the back clock
          - 143 -> Speed difference > 15Hz protection between the real and the setting speed

  - platform: template
    name: "Fault 1 Error Code"
    id: "${devicename}_fault_1_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_one = id(${devicename}_fault_1).state;
      if (fault_one >= 0 && fault_one <= 143) {
        return std::to_string(fault_one);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9

  - platform: template
    name: "Fault 2 Error Code"
    id: "${devicename}_fault_2_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_two = id(${devicename}_fault_2).state;
      if (fault_two >= 0 && fault_two <= 143) {
        return std::to_string(fault_two);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9

  - platform: template
    name: "Fault 3 Error Code"
    id: "${devicename}_fault_3_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_three = id(${devicename}_fault_3).state;
      if (fault_three >= 0 && fault_three <= 143) {
        return std::to_string(fault_three);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Type"
    id: "${devicename}_home_appliance_type"
    icon: mdi:state-machine
    register_type: holding
    address: 0xc8
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      int idx = item->offset;
      std::string z = "";
      uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
      if ((rawdata >> 8) == 7) {
        z = "Air to water heat pump";
      } else {
        z = std::to_string(data[idx]);
      }
      return {z};
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Sub Type"
    id: "${devicename}_home_appliance_sub_type"
    icon: "mdi:information-box-outline"
    register_type: holding
    address: 0xc8
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      int idx = item->offset;
      std::string z = "";
      uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
      if (((rawdata & 0x000F) ) == 2) {
        z = "R32";
      } else {
        z = std::to_string(rawdata & 0x0F) ;
      }
      return {z};
      
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Product Code"
    id: "${devicename}_home_appliance_product_code"
    icon: "mdi:information-box-outline"
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    address: 0xc8
    lambda: |-
      int idx = item->offset;
      std::string z = "";
      uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
      if (((rawdata & 0x00F0) >> 4) == 4) {
        z = "4";
      } else {
        z = std::to_string((rawdata & 0x00F0) >> 4);
      }
      return {z};

interval:
  - interval: 1h
    then:
      - lambda: |-
          // Reset compressor start count every hour
          id(compressor_start_count) = 0;
          
  - interval: 30s
    then:
      - lambda: |-
          // Freeze Protection and Overheat Protection with DHT11 Failsafe
          // This runs independently of WiFi/HA connection
          
          float current_temp = NAN;
          bool using_fallback = false;
          
          // Try to get temperature from DHT11 adapter sensor first
          // NOTE: DHT11 always reads in Celsius, thresholds are in Fahrenheit
          float dht_temp = id(${devicename}_adapter_temp).state;
          if (!isnan(dht_temp)) {
            // Convert DHT11 reading from Celsius to Fahrenheit for threshold comparison
            current_temp = dht_temp * 1.8 + 32.0;
            using_fallback = false;
            ESP_LOGD("protection", "Using DHT11 adapter temp: %.1f°C (%.1f°F)", dht_temp, current_temp);
          } else {
            // DHT11 failed, try fallback to Return Air Temperature
            float return_temp = id(${devicename}_return_air_temperature).state;
            if (!isnan(return_temp)) {
              // Return Air sensor state depends on use_fahrenheit setting
              if (id(use_fahrenheit)) {
                current_temp = return_temp;  // Already in Fahrenheit
              } else {
                current_temp = return_temp * 1.8 + 32.0;  // Convert from Celsius to Fahrenheit
              }
              using_fallback = true;
              ESP_LOGW("protection", "DHT11 sensor unavailable, using Return Air temp fallback: %.1f°F", current_temp);
            } else {
              // Both sensors failed
              ESP_LOGE("protection", "CRITICAL: Both DHT11 and Return Air sensors unavailable! Temperature protection DISABLED.");
              id(using_fallback_temp_sensor) = false;
              return;
            }
          }
          
          // Update global flag for sensor status
          id(using_fallback_temp_sensor) = using_fallback;
          
          // Check if temperature is valid
          if (isnan(current_temp)) {
            ESP_LOGW("protection", "Temperature sensor reading invalid, skipping protection check");
            return;
          }
          
          // Freeze Protection: If temp falls below minimum, switch to heat
          if (current_temp < id(freeze_protection_temp)) {
            ESP_LOGW("protection", "FREEZE PROTECTION ACTIVATED: %.1f°F < %.1f°F%s", 
                     current_temp, id(freeze_protection_temp), using_fallback ? " (using fallback sensor)" : "");
            if (id(${devicename}_operational_mode).state != "Heat" && id(${devicename}_operational_mode).state != "Auto") {
              auto call = id(${devicename}_operational_mode).make_call();
              call.set_option("Heat");
              call.perform();
              id(protection_mode_active) = true;
              ESP_LOGI("protection", "Switched to Heat mode for freeze protection");
            }
          }
          // Overheat Protection: If temp exceeds maximum, switch to cool
          else if (current_temp > id(overheat_protection_temp)) {
            ESP_LOGW("protection", "OVERHEAT PROTECTION ACTIVATED: %.1f°F > %.1f°F%s", 
                     current_temp, id(overheat_protection_temp), using_fallback ? " (using fallback sensor)" : "");
            if (id(${devicename}_operational_mode).state != "Cool" && id(${devicename}_operational_mode).state != "Auto") {
              auto call = id(${devicename}_operational_mode).make_call();
              call.set_option("Cool");
              call.perform();
              id(protection_mode_active) = true;
              ESP_LOGI("protection", "Switched to Cool mode for overheat protection");
            }
          }
          // Temperature is within safe range
          else {
            if (id(protection_mode_active)) {
              ESP_LOGI("protection", "Temperature back to safe range: %.1f°F", current_temp);
              id(protection_mode_active) = false;
            }
          }

  - interval: 2s
    then:
      - lambda: |-
          static bool was_running = false;
          bool is_running = id(compressor_running).state;

          if (!was_running && is_running) {
            id(compressor_start_count) += 1;
          }

          was_running = is_running;
